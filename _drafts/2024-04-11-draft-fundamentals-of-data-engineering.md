---
layout: post
title:  "書籍「データエンジニアリングの基礎」を読んでみた感想"
date:   2024-04-11 21:27:00 +0900
categories:
tags: book data-engineering
---

{% include tag.html %}

Table of Content:
- Table of Content
{:toc}

<!-- # h1 -->

こんにちは。i9wa4 です。

[O'Reilly Japan - データエンジニアリングの基礎](https://www.amazon.co.jp/dp/4297114283)

目次をコピーして特筆すべき点は適宜感想を書き残していく形にします。

## 1. 概要と各節毎の感想

### 1.1. Ⅰ部 データエンジニアリングの基礎と構成要素

#### 1.1.1. 1章 データエンジニアリング概説

- 1.1 データエンジニアリングとは何か
    - 1.1.1 データエンジニアリングの定義
        - > データエンジニアは、データエンジニアリングライフサイクルを管理する。データエンジニアリングライフサイクルは、ソースシステムからのデータ取得に初まり、分析や機械学習などへのデータ提供に終わる。
    - 1.1.2 データエンジニアリングライフサイクル
    - 1.1.3 データエンジニアの発展
        - 歴史を振り返る節。ビッグデータエンジニアは、今やただの「データエンジニア」。
    - 1.1.4 データエンジニアリングとデータサイエンス
- 1.2 データエンジニアリングのスキルと活動
    - 1.2.1 データ成熟度とデータエンジニア
    - 1.2.2 データエンジニアに求められる背景知識とスキル
    - 1.2.3 ビジネス上の責務
    - 1.2.4 技術的責務
    - 1.2.5 データエンジニアの役割のスペクトラム：タイプAからタイプBまで
- 1.3 組織内でのデータエンジニアリング
    - 1.3.1 内向きデータエンジニアと外向きデータエンジニア
    - 1.3.2 データエンジニアと他の技術職
    - 1.3.3 データエンジニアとビジネスリーダーシップ
- 1.4 結論
- 1.5 参考資料

#### 1.1.2. 2章 データエンジニアリングライフサイクル

2.1 データエンジニアリングライフサイクルとは何か？
2.1.1 データライフサイクルとデータエンジニアリングライフサイクル
2.1.2 生成：ソースシステム
2.1.3 保存（ストレージ）
2.1.4 取り込み
2.1.5 変換
2.1.6 データの提供
2.2 データエンジニアリングにおける主要な底流
2.2.1 セキュリティ
2.2.2 データ管理
2.2.3 DataOps
2.2.4 データアーキテクチャ
2.2.5 オーケストレーション
2.2.6 ソフトウェアエンジニアリング
2.3 結論
2.4 参考資料

#### 1.1.3. 3章 適切なデータアーキテクチャの設計

3.1 データアーキテクチャとは何か？
3.1.1 エンタープライズアーキテクチャとは何か？
3.1.2 データアーキテクチャの定義
3.1.3 「良い」データアーキテクチャ
3.2 良いデータアーキテクチャの原則
原則1：共通コンポーネントを賢く選択する
原則2：障害に備える
原則3：スケーラビリティ設計
原則4：アーキテクチャはリーダーシップだ
原則5：常に設計し続ける
原則6：疎結合システムを構築する
原則7：可逆な決定をする
原則8：セキュリティを優先する
原則9：FinOpsを活用する
3.3 主要なアーキテクチャの概念
3.3.1 ドメインとサービス
3.3.2 分散システム、スケーラビリティ、障害に備えた設計
3.3.3 密結合と疎結合：ティア、モノリス、マイクロサービス
3.3.4 ユーザアクセス：シングルテナントとマルチテナント
3.3.5 イベント駆動アーキテクチャ
3.3.6 ブラウンフィールドプロジェクトとグリーンフィールドプロジェクト
3.4 データアーキテクチャの例と種類
3.4.1 データウェアハウス
3.4.2 データレイク
3.4.3 次世代データレイクとデータプラットフォームの収斂
3.4.4 モダンデータスタック
3.4.5 Lambdaアーキテクチャ
3.4.6 Kappaアーキテクチャ
3.4.7 Dataflowモデル、バッチ、ストリームの統合
3.4.8 IoTのためのアーキテクチャ
3.4.9 データメッシュ
3.4.10 その他のデータアーキテクチャ
3.5 データアーキテクチャの設計にかかわるのは誰か
3.6 結論
3.7 参考資料

#### 1.1.4. 4章 データエンジニアリングライフサイクルにおけるテクノロジの選択

4.1 チームのサイズと容量
4.2 市場投入までのスピード
4.3 相互運用性
4.4 コスト最適化とビジネス価値
4.4.1 総所有コスト（TCO）
4.4.2 所有の総機会費用
4.4.3 FinOps
4.5 現在vs.未来：不変テクノロジvs.一過性テクノロジ
4.5.1 アドバイス
4.6 設置場所
4.6.1 オンプレミス
4.6.2 クラウド
4.6.3 ハイブリッドクラウド
4.6.4 マルチクラウド
4.6.5 非中央集権型計算：ブロックチェーンとエッジ
4.6.6 アドバイス
4.6.7 クラウドからオンプレミスへの本国回帰
4.7 構築vs.購入
4.7.1 オープンソースソフトウェア
4.7.2 プロプライエタリなウォールドガーデン
4.7.3 アドバイス
4.8 モノリスvs.モジュール
4.8.1 モノリス
4.8.2 モジュール性
4.8.3 分散モノリスパターン
4.8.4 アドバイス
4.9 サーバレスvs.サーバ
4.9.1 サーバレス
4.9.2 コンテナ
4.9.3 サーバとサーバレスの評価方法
4.9.4 アドバイス
4.10 最適化、性能、ベンチマーク戦争
4.10.1 1990年代の「ビッグデータ」
4.10.2 無意味なコスト比較
4.10.3 非対称な最適化
4.10.4 購入者責任
4.11 底流とテクノロジ選択への影響
4.11.1 データ管理
4.11.2 DataOps
4.11.3 データ管理
4.11.4 オーケストレーションの例：Airflow
4.11.5 ソフトウェアエンジニアリング
4.12 結論
4.13 参考資料

### 1.2. Ⅱ部 データエンジニアリングライフサイクルの詳細

#### 1.2.1. 5章 ソースシステムにおけるデータ生成

5.1 データソース：データはどのように生成されるのか？
5.2 ソースシステム：主要な概念
5.2.1 ファイルと非構造化データ
5.2.2 API
5.2.3 アプリケーションデータベース（OLTPシステム）
5.2.4 OLAP：オンラインアナリティクス処理システム
5.2.5 変更データキャプチャ
5.2.6 ログ
5.2.7 データベースログ
5.2.8 CRUD
5.2.9 インサートオンリー
5.2.10 メッセージとストリーム
5.2.11 時間と時刻の種類
5.3 ソースシステムの実践的な詳細
5.3.1 データベース
5.3.2 API
5.3.3 データ共有
5.3.4 サードパーティデータソース
5.3.5 メッセージキューとイベントストリーミングパイプライン
5.4 一緒に仕事する人
5.5 底流とそのソースシステムへの影響
5.5.1 セキュリティ
5.5.2 データ管理
5.5.3 DataOps
5.5.4 データアーキテクチャ
5.5.5 オーケストレーション
5.5.6 ソフトウェアエンジニアリング
5.6 結論
5.7 参考資料

#### 1.2.2. 6章 ストレージへの保存

6.1 データストレージの原材料
6.1.1 磁気ディスクドライブ
6.1.2 SSD（ソリッドステートドライブ）
6.1.3 RAM（ランダムアクセスメモリ）
6.1.4 ネットワークとCPU
6.1.5 シリアライズ
6.1.6 圧縮
6.1.7 キャッシュ
6.2 データストレージシステム
6.2.1 単体サーバvs.分散ストレージ
6.2.2 結果整合性と強い一貫性
6.2.3 ファイルストレージ
6.2.4 ブロックストレージ
6.2.5 オブジェクトストレージ
6.2.6 キャッシュとメモリベースのストレージシステム
6.2.7 HDFS（Hadoop分散ファイルシステム）
6.2.8 ストリーミングストレージ
6.2.9 インデックス、パーティション分割、クラスタリング
6.3 データエンジニアリングにおけるストレージ抽象
6.3.1 データウェアハウス
6.3.2 データレイク
6.3.3 データレイクハウス
6.3.4 データプラットフォーム
6.3.5 ストリーム・トゥ・バッチストレージアーキテクチャ
6.4 ストレージの要点とトレンド
6.4.1 データカタログ
6.4.2 データ共有
6.4.3 スキーマ
6.4.4 コンピュートとストレージの分離
6.4.5 データストレージのライフサイクルとデータ保持
6.4.6 シングルテナントvs.マルチテナント
6.5 一緒に仕事する人
6.6 底流
6.6.1 セキュリティ
6.6.2 データ管理
6.6.3 DataOps
6.6.4 データアーキテクチャ
6.6.5 オーケストレーション
6.6.6 ソフトウェアエンジニアリング
6.7 結論
6.8 参考資料

#### 1.2.3. 7章 データ取り込み

7.1 データ取り込みとは
7.2 取り込みフェーズにおけるエンジニアリング上の重要な検討事項
7.2.1 区切りありデータvs.区切りなしデータ
7.2.2 頻度
7.2.3 同期vs.非同期
7.2.4 シリアライズとデシリアライズ
7.2.5 スループットとスケーラビリティ
7.2.6 信頼性と耐久性
7.2.7 ペイロード
7.2.8 プッシュvs.プルvs.ポーリング
7.3 バッチ取り込みに関する検討事項
7.3.1 スナップショットまたは差分抽出
7.3.2 ファイルのエクスポートと取り込み
7.3.3 ETL vs. ELT
7.3.4 挿入、更新とバッチサイズ
7.3.5 データの移行
7.4 メッセージ取り込みとストリーム取り込みの検討事項
7.4.1 スキーマ進化
7.4.2 遅延到着データ
7.4.3 順序と多重配送
7.4.4 リプレイ
7.4.5 TTL（Time to Live）
7.4.6 メッセージサイズ
7.4.7 エラー処理とデッドレターキュー
7.4.8 消費者によるプルとプッシュ
7.4.9 場所
7.5 データ取り込みの方法
7.5.1 直接データベース接続
7.5.2 CDC：変更データキャプチャ
7.5.3 API
7.5.4  メッセージキューおよびイベントストリーミングプラットフォーム
7.5.5 マネージドデータコネクタ
7.5.6 オブジェクトストレージを用いたデータの移動
7.5.7 EDI
7.5.8 データベースとファイルのエクスポート
7.5.9 一般的なファイルフォーマットに関する現実的な問題
7.5.10 シェル
7.5.11 SSH
7.5.12 SFTPとSCP
7.5.13 Webhook
7.5.14 Webインタフェース
7.5.15 Webスクレイピング
7.5.16 データ移行のための転送アプライアンス
7.5.17 データ共有
7.6 一緒に仕事する人
7.6.1 上流の利害関係者
7.6.2 下流の利害関係者
7.7 底流
7.7.1 セキュリティ
7.7.2 データ管理
7.7.3 DataOps
7.7.4 オーケストレーション
7.7.5 ソフトウェアエンジニアリング
7.8 結論
7.9 参考資料

#### 1.2.4. 8章 クエリ、データモデリング、変換

8.1 クエリ
8.1.1 クエリとは何か？
8.1.2 クエリのライフサイクル
8.1.3 クエリオプティマイザ
8.1.4 クエリ性能の向上
8.1.5 ストリームデータに対するクエリ
8.2 データモデリング
8.2.1 データモデルとは何か？
8.2.2 概念データモデル、論理データモデル、物理データモデル
8.2.3 正規化
8.2.4 バッチアナリティクスデータのモデリング手法
8.2.5 ストリームデータモデリング
8.3 変換
8.3.1 バッチ変換
8.3.2 マテリアライズドビュー、フェデレーテッドクエリ、データ仮想化
8.3.3 ストリーミング変換と処理
8.4 一緒に仕事する人
8.4.1 上流の利害関係者
8.4.2 下流の利害関係者
8.5 底流
8.5.1 セキュリティ
8.5.2 データ管理
8.5.3 DataOps
8.5.4 データアーキテクチャ
8.5.5 オーケストレーション
8.5.6 ソフトウェアエンジニアリング
8.6 結論
8.7 参考資料

#### 1.2.5. 9章 アナリティクス、機械学習、リバースETL へのデータの提供

9.1 データ提供に関する一般的な考慮事項
9.1.1 信頼
9.1.2 ユースケースは何か？ ユーザは誰か？
9.1.3 データプロダクト
9.1.4 セルフサービスにするべきか？
9.1.5 データ定義とロジック
9.1.6 データメッシュ
9.2 アナリティクス
9.2.1 ビジネスアナリティクス
9.2.2 オペレーショナルアナリティクス
9.2.3 組み込みアナリティクス
9.3 機械学習
9.4 データエンジニアがMLについて知っておくべきこと
9.5 アナリティクスやMLに対してデータを提供する方法
9.5.1 ファイル交換
9.5.2 データベース
9.5.3 ストリーミングシステム
9.5.4 クエリフェデレーション
9.5.5 データ共有
9.5.6 セマンティックレイヤとメトリクスレイヤ
9.5.7 ノートブックによるデータの提供
9.6 リバースETL
9.7 一緒に仕事する人
9.8 底流
9.8.1 セキュリティ
9.8.2 データ管理
9.8.3 DataOps
9.8.4 データアーキテクチャ
9.8.5 オーケストレーション
9.8.6 ソフトウェアエンジニアリング
9.9 結論
9.10 参考資料

### 1.3. Ⅲ部 セキュリティとプライバシー、およびデータエンジニアリングの未来

#### 1.3.1. 10章 セキュリティとプライバシー

10.1 人材
10.1.1 ネガティブ思考の力
10.1.2 常に心配性でいる
10.2 プロセス
10.2.1 劇場型セキュリティvs.習慣としてのセキュリティ
10.2.2 アクティブセキュリティ
10.2.3 最小権限の原則
10.2.4 クラウドでの責任共有
10.2.5 常にデータのバックアップを取る
10.2.6 セキュリティポリシーの例
10.3 テクノロジ
10.3.1 パッチとシステムアップデート
10.3.2 暗号化
10.3.3 ロギング、監視、アラート
10.3.4 ネットワークアクセス
10.3.5 低レイヤデータエンジニアリングにおけるセキュリティ
10.4 結論
10.5 参考資料

#### 1.3.2. 11章 データエンジニアリングの未来

11.1 データエンジニアリングライフサイクルは消えない
11.2 複雑さの衰退と使いやすいデータツールの興隆
11.3 クラウドスケールデータOSと相互運用性の改善
11.4 「大企業的」データエンジニアリング
11.5 職種名と担当範囲は変化する
11.6  モダンデータスタックからの脱却とライブデータスタックへの移行
11.6.1 ライブデータスタック
11.6.2  ストリーミングパイプラインとリアルタイムアナリティクスデータベース
11.6.3 データとアプリケーションの融合
11.6.4 アプリケーションとML間での緊密なフィードバック
11.6.5 ダークマターデータとスプレッドシートの興隆？
11.7 結論

### 1.4. 付録

#### 1.4.1. 付録A シリアライズと圧縮技術の詳細

A.1 シリアライズフォーマット
A.1.1 行ベースのシリアライズ
A.1.2 カラム型シリアライズ
A.1.3 ハイブリッドシリアライズ
A.2 データベースストレージエンジン
A.3 圧縮：gzip、bzip2、Snappyなど

#### 1.4.2. 付録B クラウドのネットワーク

B.1 クラウドネットワークのトポロジ
B.1.1 データエグレス料金
B.1.2 アベイラビリティゾーン
B.1.3 リージョン
B.1.4 GCP固有のネットワークとマルチリージョン冗長化
B.1.5 クラウドへの直接ネットワーク接続
B.2 CDN
B.3 データエグレス料金の未来

## 2. 全体を通した感想
